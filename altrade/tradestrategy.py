#
# Tradingstrategy.py
#

import Queue
from abc import ABCMeta, abstractmethod
from math import floor

import numpy as np

from event import SignalEvent
from src.tdx import Math, utilities

logger = utilities.initlog()


class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")


class BollLineMinutesStrategy(Strategy):
    """
    This is a strategy that goes SHORT all of the symbols as
    soon as a bar is received. It will caculate the current price wether its above 
    the high boll line then exit a position, Sell it. as when price goes down exceed
    the low boll line Buy back the same volume.  It is primarily used as a intraday mechanism
    for the Strategy class as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy or sell signal is given, these are set to True
        self.bought, self.sold = self._calculate_initial_trade()

    def _calculate_initial_trade(self):
        """
        Adds keys to the bought/sold dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        sold = {}
        for s in self.symbol_list:
            bought[s] = False
            sold[s] = False
        return bought, sold

    def crossoversignal(self, name, now_price, boll_np):
        """ if the now price go cross the bolling line
        :param name :
        :param now_price: the newest price at the moment
        :param boll_np:  bolling upper , mid, lower band values
        :type boll_np: numpy
        :return: signal : LONG for buy , SHORT for sell
        """
        bol_upper, bol_lower = boll_np[0][-1], boll_np[2][-1]
        if (now_price -
                bol_upper) >= 0.02:  # in the 2 cent range, near the upper
            logger.info("!!!!Stock %s Up Cross Boll Upperline " % name)
            logger.debug("nowprice==>%s bolupper ==>%s" %
                         (now_price, bol_upper))
            signal = "SHORT"  # sell short
        elif (now_price - bol_lower) <= -0.02:
            logger.info("!!!!Stock %s Down Cross Boll Low \n" % name)
            logger.debug("now_price==>%s bolower ==>%s" %
                         (now_price, bol_lower))
            signal = "LONG"  # buy short
        else:
            signal = "None"
        return signal

    def calculate_signals(self, event):
        """
        For "Bollinger Strategy" we generate a single signal per symbol
        This means we are constantly long the market from the date of strategy
        initialisation.
        Parameters
        event - A MarketEvent object.
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=80)
                npbars = np.array(bars)
                # highnp = npbars.T[3]    # high value in the numpy bars array
                # lownp = npbars.T[4]     # lows
                # opennp = npbars.T[1]    # open
                closenp = npbars.T[5]  # close

                # TODO 1: use slope level to forecast the price trend!!
                # TODO 2: use or not use the market price(& vol) it depends on slope
                # TODO 3: use meanline and bias indictor  meanline price = tot_amount/totvol
                # barnumber = 30
                trend_slope = Math.TrendSlope(closenp[-30:])
                volumenp = npbars.T[6]  # volume,when greater than 2*np.std
                midvol = np.mean(volumenp)
                nowvol = volumenp[-1]
                stdvol = np.std(volumenp)
                nowprice = closenp[-1]  # latest price
                # if bars is not None and bars != []:
                if bars:
                    # TODO: bolling up and low line distance and slope up and down
                    # check 1 ,2,3 ,... more minutes later
                    # and the volume is much bigger than normal
                    boll_np = Math.BollLine(closenp)
                    signal = self.crossoversignal(s, nowprice, boll_np)
                    signal_strength = floor(
                        (nowvol - midvol) / stdvol)  # last 80
                    if signal != "None" and signal_strength >= 1:
                        # bars[0][1] is datetime
                        # test print
                        # print "SignalEvent %s ==%s===>@@ %s==@%s" % (signal, bars[-1][0], bars[-1][1], nowprice)
                        # print "Signal Strength=== %f <===" % signal_strength
                        # print "Trend slope rate ===>", trend_slope
                        # TODO : estimated algorithm of execution price
                        #exeprice = nowprice + 0.10 if trend_slope > 0.01 else nowprice-0.1
                        exeprice = nowprice
                        # the last item is the newest/current state
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal_event = SignalEvent(bars[-1][0], bars[-1][1],
                                                   signal, signal_strength,
                                                   exeprice)
                        #TODO: pitfall==> check available shares with T+1 regulation
                        self.events.put(signal_event)
                        #set trading bought/sold flag
                        #TODO : caculated holdings updated and left . for temp below!!
                        self.sold = True if signal == "SHORT" else False
                        self.bought = True if signal == "LONG" else False


if __name__ == '__main__':
    from datasource import HistoricTDXDataHandler
    events = Queue.Queue()
    symbol_list = ["300024"]
    datadir = "D:\\tools\\new_tdx\\vipdoc\\sz\\minline"
    tbars = HistoricTDXDataHandler(events, datadir, symbol_list)
    strategy = BollLineMinutesStrategy(tbars, events)
    tbars.load_bars(500)
    event = events.get()
    for i in range(0, 2400):
        tbars.update_bars()
        strategy.calculate_signals(event)
        #print event.type
